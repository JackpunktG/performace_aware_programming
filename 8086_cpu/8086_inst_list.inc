#ifndef INSTRUCTION
#define INSTRUCTION(Mnemonic, Encoding, ...) {Op_##Mnemonic, Encoding, __VA_ARGS__},
#endif

#ifndef INST
#define INST INSTRUCTION
#endif

#define B(Bits) {Bits_OP, sizeof(#Bits)-1, 0, 0b##Bits}
#define BL(Bits) {Bits_Literal, sizeof(#Bits)-1, 0, 0b##Bits}
#define D {Bits_D, 1}
#define W {Bits_W, 1}
#define S {Bits_S, 1}
#define V {Bits_V, 1}
#define Z {Bits_Z, 1}


#define RM {Bits_RM, 3}
#define MOD {Bits_MOD, 2}
#define REG {Bits_REG, 3}
#define SR {Bits_SR, 2}

#define IP8 {Bits_IP_INC8, 8}

#define DISP_L {Bits_Disp_L, 8}
#define DISP_H {Bits_Disp_H, 8}
#define DATA_L {Bits_Data_L, 8}
#define DATA_H {Bits_Data_H, 8}

INSTRUCTION(mov, {B(100010), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(mov, {B(1100011), W, MOD, BL(000), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(mov, {B(1011), W, REG, DATA_L, DATA_H})
INST(mov, {B(1010000), W, DISP_L, DISP_H})
INST(mov, {B(1010001), W, DISP_L, DISP_H})
INST(mov, {B(10001110), MOD, BL(0), SR, RM, DISP_L, DISP_H})
INST(mov, {B(10001100), MOD, BL(0), SR, RM, DISP_L, DISP_H})

// Arithmetic and Logical Instructions
INSTRUCTION(add, {B(000000), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(add, {B(100000), S, W, MOD, BL(000), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(add, {B(0000010), W, DATA_L, DATA_H})
INSTRUCTION(or, {B(000010), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(or, {B(100000), S, W, MOD, BL(001), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(or, {B(0000110), W, DATA_L, DATA_H})
INSTRUCTION(adc, {B(000100), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(adc, {B(100000), S, W, MOD, BL(010), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(adc, {B(0001010), W, DATA_L, DATA_H})
INSTRUCTION(sbb, {B(000110), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(sbb, {B(100000), S, W, MOD, BL(011), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(sbb, {B(0001110), W, DATA_L, DATA_H})
INSTRUCTION(and, {B(001000), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(and, {B(100000), S, W, MOD, BL(100), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(and, {B(0010010), W, DATA_L, DATA_H})
INSTRUCTION(sub, {B(001010), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(sub, {B(100000), S, W, MOD, BL(101), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(sub, {B(0010110), W, DATA_L, DATA_H})
INSTRUCTION(xor, {B(001100), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(xor, {B(100000), S, W, MOD, BL(110), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(xor, {B(0011010), W, DATA_L, DATA_H})
INSTRUCTION(cmp, {B(001110), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(cmp, {B(100000), S, W, MOD, BL(111), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(cmp, {B(0011110), W, DATA_L, DATA_H})
INSTRUCTION(test, {B(000100), D, W, MOD, REG, RM, DISP_L, DISP_H})
INST(test, {B(1111011), W, MOD, BL(000), RM, DISP_L, DISP_H, DATA_L, DATA_H})
INST(test, {B(1010100), W, DATA_L})
INSTRUCTION(inc, {B(1111111), W, MOD, BL(000), RM, DISP_L, DISP_H})
INST(inc, {B(01000), REG})
INSTRUCTION(dec, {B(1111111), W, MOD, BL(001), RM, DISP_L, DISP_H})
INST(dec, {B(01001), REG})
INSTRUCTION(neg, {B(1111011), W, MOD, BL(011), RM, DISP_L, DISP_H})
INSTRUCTION(aaa, {B(00110111)})
INSTRUCTION(daa, {B(00100111)})

// Compare extended 
INSTRUCTION(ass, {B(00111111)})
INSTRUCTION(das, {B(00101111)})
INSTRUCTION(cbw, {B(10011000)})
INSTRUCTION(cbd, {B(10011001)})
INSTRUCTION(aam, {B(11010100), BL(00001010)})
INSTRUCTION(aad, {B(11010101), BL(00001010)})
INSTRUCTION(mul, {B(1111011), W, MOD, BL(100), RM, DISP_L, DISP_H})
INSTRUCTION(imul, {B(1111011), W, MOD, BL(101), RM, DISP_L, DISP_H})
INSTRUCTION(div, {B(1111011), W, MOD, BL(110), RM, DISP_L, DISP_H})
INSTRUCTION(idiv, {B(1111011), W, MOD, BL(111), RM, DISP_L, DISP_H})

// Logic
INSTRUCTION(rol, {B(110100), V, W, MOD, BL(000), RM, DISP_L, DISP_H})
INSTRUCTION(ror, {B(110100), V, W, MOD, BL(001), RM, DISP_L, DISP_H})
INSTRUCTION(rcl, {B(110100), V, W, MOD, BL(010), RM, DISP_L, DISP_H})
INSTRUCTION(rcr, {B(110100), V, W, MOD, BL(011), RM, DISP_L, DISP_H})
INSTRUCTION(shl, {B(110100), V, W, MOD, BL(100), RM, DISP_L, DISP_H})
INSTRUCTION(shr, {B(110100), V, W, MOD, BL(101), RM, DISP_L, DISP_H})
INSTRUCTION(not, {B(1111011), W, MOD, BL(010), RM, DISP_L, DISP_H})
INSTRUCTION(sar, {B(110100), V, W, MOD, BL(111), RM, DISP_L, DISP_H})

// Input from
INSTRUCTION(in, {B(1110010), W, DATA_L})
INST(in, {B(1110110), W})
// Output to
INSTRUCTION(out, {B(110011), W, DATA_L})
INST(out, {B(1110111), W})
INSTRUCTION(elat, {B(11010111)})
INSTRUCTION(lea, {B(10001101), MOD, REG, RM, DISP_L, DISP_H})
INSTRUCTION(lds, {B(11000101), MOD, REG, RM, DISP_L, DISP_H})
INSTRUCTION(les, {B(11000100), MOD, REG, RM, DISP_L, DISP_H})
INSTRUCTION(lahf, {B(10011111)})
INSTRUCTION(safh, {B(10011110)})
INSTRUCTION(pushf, {B(10011100)})
INSTRUCTION(popf, {B(10011101)})

// string manipulation
INSTRUCTION(rep, {B(1111001), Z, BL(0000000), W})
INSTRUCTION(movs, {B(1010010), W})
INSTRUCTION(cmps, {B(1010011), W})
INSTRUCTION(stds, {B(1010101), W})
INSTRUCTION(lods, {B(1010110), W})
INSTRUCTION(scas, {B(1010111), W})

// Return from call
INSTRUCTION(ret, {B(11000011)})
INST(ret, {B(11000010), DATA_L, DATA_H})
INSTRUCTION(retf, {B(11001011)})
INST(retf, {B(11001010), DATA_L, DATA_H})


// conditional jumps
INSTRUCTION(je, {B(01110100), IP8})
INSTRUCTION(jl, {B(01111100), IP8})
INSTRUCTION(jle, {B(01111110), IP8})
INSTRUCTION(jb, {B(01110010), IP8})
INSTRUCTION(jbe, {B(01110110), IP8})
INSTRUCTION(jp, {B(01111010), IP8})
INSTRUCTION(jo, {B(01110000), IP8})
INSTRUCTION(js, {B(01111000), IP8})
INSTRUCTION(jne, {B(01110101), IP8})
INSTRUCTION(jnl, {B(01111101), IP8})
INSTRUCTION(jnle, {B(01111111), IP8})
INSTRUCTION(jnb, {B(01110011), IP8})
INSTRUCTION(jnbe, {B(01110111), IP8})
INSTRUCTION(jnp, {B(01111011), IP8})
INSTRUCTION(jno, {B(01110001), IP8})
INSTRUCTION(jns, {B(01111001), IP8})
INSTRUCTION(loop, {B(11100010), IP8})
INSTRUCTION(loopz, {B(11100001), IP8})
INSTRUCTION(loopnz, {B(11100000), IP8})
INSTRUCTION(jcxz, {B(11100011), IP8})

#undef INST
#undef INSTRUCTION

#undef B
#undef D
#undef S
#undef W
#undef V

#undef RM
#undef MOD
#undef REG

#undef DISP_L
#undef DISP_H
#undef DATA_L
#undef DATA_H

